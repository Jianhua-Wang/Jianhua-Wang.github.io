<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>自建机场教程</title>
    <link href="/2023/01/03/%E8%87%AA%E5%BB%BA%E6%9C%BA%E5%9C%BA/"/>
    <url>/2023/01/03/%E8%87%AA%E5%BB%BA%E6%9C%BA%E5%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>自建机场主要分五部分，以下是本教程使用的工具和配置：</p><ol><li>注册域名，本教程使用namesilo</li><li>在cloudflare中进行DNS设置</li><li>购买VPS，本教程使用vultr</li><li>部署代理服务器，本教程使用trojan协议</li><li>配置本地代理，本教程使用Mac环境</li></ol><h2 id="1-注册域名"><a href="#1-注册域名" class="headerlink" title="1. 注册域名"></a>1. 注册域名</h2><p>注册域名和DNS都是为了增加隐蔽性，后面的一键部署脚本还会自动安装SSL证书和搭建伪装网页，也都是为了达到隐蔽的目的。</p><p>注册域名可以购买域名也可以使用免费域名，<a href="https://www.namesilo.com/">namesilo</a>上.xyz和.top的域名第一年1.26刀，续费也只有4.5刀，也比较便宜，以后也可以用来搭建自己的网站。</p><h3 id="1-1-购买域名"><a href="#1-1-购买域名" class="headerlink" title="1.1 购买域名"></a>1.1 购买域名</h3><p>注册之后验证邮箱，在搜索框中搜索想要的域名，一般xyz和top域名最便宜。</p><p><img src="/image/20230103/Untitled.png"></p><p>点击add之后再点击网页右上角的购物车按钮</p><p><img src="/image/20230103/Untitled%201.png"></p><p>点击checkout之后选择支付宝支付。</p><h3 id="1-2-弃用namesilo-DNS"><a href="#1-2-弃用namesilo-DNS" class="headerlink" title="1.2 弃用namesilo DNS"></a>1.2 弃用namesilo DNS</h3><p>在主页右上角选择My Account进入账户管理页面</p><p><img src="/image/20230103/Untitled%202.png"></p><p>点击Account Domains后的1进入域名管理页面，如果显示的是0就稍等几分钟刷新看看。</p><p><img src="/image/20230103/Untitled%203.png"></p><p>点击蓝色的小球进入DNS管理页面。</p><p><img src="/image/20230103/Untitled%204.png"></p><p>点击DELETE删除所有的DNS设置。</p><p><img src="/image/20230103/Untitled%205.png"></p><h2 id="2-在cloudflare中进行DNS设置"><a href="#2-在cloudflare中进行DNS设置" class="headerlink" title="2. 在cloudflare中进行DNS设置"></a>2. 在cloudflare中进行DNS设置</h2><p><a href="https://dash.cloudflare.com/login">cloudflare</a>是非常好的域名解析服务商，甚至可以使用他们提供的SSL证书。</p><h3 id="2-1-添加域名"><a href="#2-1-添加域名" class="headerlink" title="2.1 添加域名"></a>2.1 添加域名</h3><p>注册之后验证邮箱并登陆。不习惯英文可以右上角切换中文页面。、</p><p>点击主页的添加站点。</p><p><img src="/image/20230103/Untitled%206.png"></p><p>输入在namesilo注册的域名点击添加，按提示选择免费计划，一直下一步，到最后一步的最下面找到添加cloudflare名称服务器，保留该页面。</p><p><img src="/image/20230103/Untitled%207.png"></p><h3 id="2-2-在namesilo把域名的DNS改成cloudflare"><a href="#2-2-在namesilo把域名的DNS改成cloudflare" class="headerlink" title="2.2 在namesilo把域名的DNS改成cloudflare"></a>2.2 在namesilo把域名的DNS改成cloudflare</h3><p>回到namesilo的域名管理页面，点击最后的灰色数据库图标</p><p><img src="/image/20230103/Untitled%208.png"></p><p>点击“Click here to select our Premium nameservers”，将2.1获得的两个Cloudflare名称服务器复制粘贴过来，然后点submit。</p><p><img src="/image/20230103/Untitled%209.png"></p><p>然后在回到cloudflare页面完成提交，提交之后会显示在审核，一般几分钟就通过，稍等一会刷新看看，出现下面的有效就是通过了。</p><p><img src="/image/20230103/Untitled%2010.png"></p><h3 id="2-3-配置SSL加密"><a href="#2-3-配置SSL加密" class="headerlink" title="2.3 配置SSL加密"></a>2.3 配置SSL加密</h3><p>点击上面的有效框框进入域名设置页面，点击SSL&#x2F;TLS-概述，加密模式改为完全。</p><p><img src="/image/20230103/Untitled%2011.png"></p><p>选项太多老魏就不一一截图了，在下面列出需要开启的选项吧。</p><ul><li>始终使用 HTTPS：开启。将所有使用方案 “http” 的请求重定向到 “https”。这将应用于该区域的所有 http 请求；</li><li>随机加密：开启。随机加密可以让浏览器知道你的站点提供加密连接，从而让它们从 HTTP&#x2F;2 的性能改进中受益。浏览器将继续在地址栏中显示 “http”，而不是 “https”；</li><li>TLS 1.3：开启，启用最新版本的 TLS 协议，以提高安全性和性能；</li><li>自动 HTTPS 重写：开启，自动 HTTPS 重写通过将可以使用 HTTPS 提供服务的网站上所有资源或链接的 “http” 更改为 “https” 来帮助修正混合内容；</li><li>其他选项不要碰。</li></ul><h3 id="2-4-添加子域名"><a href="#2-4-添加子域名" class="headerlink" title="2.4 添加子域名"></a>2.4 添加子域名</h3><p>添加子域名前要先购买VPS获得IP地址。</p><p>选择DNS-记录，点击添加记录。</p><p><img src="/image/20230103/Untitled%2012.png"></p><p>如下图填写，然后点击保存。</p><p><img src="/image/20230103/Untitled%2013.png"></p><h2 id="3-购买VPS"><a href="#3-购买VPS" class="headerlink" title="3. 购买VPS"></a>3. 购买VPS</h2><p>本教程使用<a href="https://www.vultr.com/">vultr</a></p><h3 id="3-1-充值"><a href="#3-1-充值" class="headerlink" title="3.1 充值"></a>3.1 充值</h3><p>注册后验证邮箱，登陆后选择billing充值，有时候会有优惠码，不过网上的有很多是过期了的，一般有充值送100刀和充多少送多少（最多送100美元）两种，但是其实赠送金额都有时间限制，充值送100刀有效期只有一个月，相当于只有第一个月免费，除非你有购买计算服务器的需求，充多少送多少的赠送金额有效期是一年，一个月5美元的话，充25送25是最划算的。我就是一下子没看清楚冲了100美元，好在是可以退款。</p><p><img src="/image/20230103/Untitled%2014.png"></p><h3 id="3-2-启动VPS"><a href="#3-2-启动VPS" class="headerlink" title="3.2 启动VPS"></a>3.2 启动VPS</h3><p>点击products页面的加号按钮。</p><p><img src="/image/20230103/Untitled%2015.png"></p><p>选择cloud compute，intel regular performance</p><p><img src="/image/20230103/Untitled%2016.png"></p><p>地区选美国洛杉矶，硅谷都可以，系统选ubuntu和centos都可以。</p><p><img src="/image/20230103/Untitled%2017.png"></p><p>选择最便宜的5美元&#x2F;月，取消选择自动备份。点击deploy now启动VPS。</p><p><img src="/image/20230103/Untitled%2018.png"></p><p>大概等个十分钟左右，就可以在products页面看到运行的VPS</p><p><img src="/image/20230103/Untitled%2019.png"></p><p>点击查看IP地址和密码，IP地址用于2.4添加指向VPS的子域名，如果更换VPS之后IP发生变化，2.4的IP地址也要同步修改，但是生效比较慢，几分钟到几个小时不等，可以ping域名看IP地址是否修改完成。</p><p><img src="/image/20230103/Untitled%2020.png"></p><h2 id="4-部署代理服务器"><a href="#4-部署代理服务器" class="headerlink" title="4 部署代理服务器"></a>4 部署代理服务器</h2><p>ssh登陆VPS，一键部署：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#下载脚本</span><br>curl -O https://raw.githubusercontent.com/atrandys/trojan/master/trojan_mult.sh<br><br><span class="hljs-comment">#添加执行权限</span><br><span class="hljs-built_in">chmod</span> +x trojan_mult.sh<br><br><span class="hljs-comment">#运行脚本</span><br>./trojan_mult.sh<br></code></pre></td></tr></table></figure><p><img src="/image/20230103/Untitled%2021.png"></p><p>选择1安装，中间会提示输入域名，输入2.4中添加的子域名，如：aa.mydomain.com，还会提示输入trojan的用户名和密码，这个密码要记好，安装完成后输出一堆json。</p><p>这个脚本除了安装trojan，还自动进行了ssl认证，伪装网页部署，访问<a href="https://aa.mydomain.com就能看到一个假的电影网站./">https://aa.mydomain.com就能看到一个假的电影网站。</a></p><h3 id="5-本地配置代理"><a href="#5-本地配置代理" class="headerlink" title="5 本地配置代理"></a>5 本地配置代理</h3><p>本教程使用<a href="https://github.com/yichengchen/clashX">clashX</a>，支持Mac&#x2F;Win&#x2F;Linux。但这里只用Mac演示。</p><p>下载clashX 配置文件模版：<a href="https://v2xtls.org/clash_template2.yaml">https://v2xtls.org/clash_template2.yaml</a></p><p>将proxies下除trojan以外的代理方式都删除，将trojan代理的server，password字段改成2.4的子域名和4中设置的密码。</p><p><img src="/image/20230103/Untitled%2022.png"></p><p>保存后放入配置文件夹，选择该配置并勾选设置为系统代理，大功告成。</p><p><img src="/image/20230103/Untitled%2023.png"></p><p>参考教程：</p><p><a href="https://www.triadprogram.com/v2ray-build-by-yourself/">https://www.triadprogram.com/v2ray-build-by-yourself/</a></p><p><a href="https://www.vpsss.net/23287.html">https://www.vpsss.net/23287.html</a></p>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VPN</tag>
      
      <tag>Mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动刷新github hosts</title>
    <link href="/2022/10/16/%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0github%20hosts/"/>
    <url>/2022/10/16/%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0github%20hosts/</url>
    
    <content type="html"><![CDATA[<p>日常工作中经常会发现GitHub的访问会不稳定，有的时候可以有的时候又不可以。实际上GitHub是没有被墙的，只是受到DNS污染，就是无法找到GitHub正确的IP地址，因此我们可以通过修改hosts的方式告诉服务器GitHub的IP是多少。</p><p>切换到root</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">su root<br></code></pre></td></tr></table></figure><p>手动更新hosts</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed -i <span class="hljs-string">&quot;/# GitHub520 Host Start/Q&quot;</span> /etc/hosts &amp;&amp; curl https://raw.hellogithub.com/hosts &gt;&gt; /etc/hosts<br></code></pre></td></tr></table></figure><p>加入cron自动更新，每分钟更新一次</p><p>修改<code>/var/spool/cron/crontabs/root</code></p><p>添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">* * * * * sed -i <span class="hljs-string">&quot;/# GitHub520 Host Start/Q&quot;</span> /etc/hosts &amp;&amp; curl https://raw.hellogithub.com/hosts &gt;&gt; /etc/hosts<br></code></pre></td></tr></table></figure><p>刷新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ service cron reload<br> * Reloading configuration files <span class="hljs-keyword">for</span> periodic <span class="hljs-built_in">command</span> scheduler cron                                                                                                                                                                         [ OK ]<br>$ crontab -l<br>* * * * * sed -i <span class="hljs-string">&quot;/# GitHub520 Host Start/Q&quot;</span> /etc/hosts &amp;&amp; curl https://raw.hellogithub.com/hosts &gt;&gt; /etc/host<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tinyproxy代理配置</title>
    <link href="/2022/10/03/tinyproxy%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/10/03/tinyproxy%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>有时候处于内网的服务器不能直接访问外网，这对下载数据和conda以及github上的软件包带来了很大困扰。此时如果有一台内网服务器可以访问的服务器，而这台服务器又可以访问外网的话，我们就可以通过tinyproxy把这台服务器当作代理服务器，让内网服务器通过代理服务器间接访问外网。</p><p>ubuntu安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install tinyproxy<br></code></pre></td></tr></table></figure><p>配置：&#x2F;etc&#x2F;tinyproxy.conf</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text"># 如果/var/log/tinyproxy/tinyproxy.log权限报错，就把下面两行改成/var/log/tinyproxy的所有者<br>User tinyproxy<br>Group tinyproxy<br><br># 设置端口<br>Port 3216<br><br># 可以设置用户名和密码<br>BasicAuth user passwd<br><br># 可以设置连接的IP地址限制<br>Allow ip<br></code></pre></td></tr></table></figure><p>启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -d debug模式，取消-d进入后台运行</span><br>$ sudo tinyproxy -d -c /etc/tinyproxy.conf<br></code></pre></td></tr></table></figure><p>查看进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ps -ef|grep tinyproxy|grep -v grep<br>tinypro+  690507       1  0 20:24 ?        00:00:00 /usr/bin/tinyproxy<br>root      691964  690216  0 20:29 pts/6    00:00:00 sudo tinyproxy -d -c /etc/tinyproxy.conf<br>root      691965  691964  0 20:29 pts/7    00:00:00 sudo tinyproxy -d -c /etc/tinyproxy.conf<br>root      691966  691965  0 20:29 pts/7    00:00:02 tinyproxy -d -c /etc/tinyproxy.conf<br></code></pre></td></tr></table></figure><p>终止</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo ps -ef|grep tinyproxy|grep -v grep|awk <span class="hljs-string">&#x27;&#123;print &quot;kill -9 &quot;$2&#125;&#x27;</span>|sudo sh<br></code></pre></td></tr></table></figure><p>配置代理</p><p>在.zshrc(bash 就是.bashrc)中加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">export http_proxy=&quot;http://ip:port&quot;<br>export https_proxy=&quot;http://ip:port&quot;<br><br># 有用户名密码验证的话<br>export http_proxy=&quot;http://user:passwd@ip:port&quot;<br>export https_proxy=&quot;http://user:passwd@ip:port&quot;<br><br></code></pre></td></tr></table></figure><p>conda不需要额外在.condarc中配置代理。</p><p>git代理配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># git设置代理</span><br>git config --global http.proxy http://127.0.0.1:1080<br>git config --global https.proxy http://127.0.0.1:1080<br><br><span class="hljs-comment"># git取消代理</span><br>git config --global --<span class="hljs-built_in">unset</span> http.proxy<br>git config --global --<span class="hljs-built_in">unset</span> https.proxy<br></code></pre></td></tr></table></figure><p>github ssh协议要走ssh隧道，编辑<code>~/.ssh/config</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host github.com<br>  HostName github.com<br>  ProxyCommand ssh hongxi@115.24.151.249 -W %h:%p<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>参考基因组下载方式汇总</title>
    <link href="/2022/09/22/%E5%8F%82%E8%80%83%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%B1%87%E6%80%BB/"/>
    <url>/2022/09/22/%E5%8F%82%E8%80%83%E5%9F%BA%E5%9B%A0%E7%BB%84%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>基因组学数据分析的第一步通常是搭建分析流程，而分析流程的第一步通常是下载分析的参考数据，这里我总结下载fasta的几种方式。</p><h2 id="UCSC-goldenPath"><a href="#UCSC-goldenPath" class="headerlink" title="UCSC goldenPath"></a>UCSC goldenPath</h2><p>以hg19为例:</p><p><a href="http://hgdownload.cse.ucsc.edu/goldenPath/hg19/bigZips/chromFa.tar.gz" title="http://hgdownload.cse.ucsc.edu/goldenPath/hg19/bigZips/chromFa.tar.gz">http://hgdownload.cse.ucsc.edu/goldenPath/hg19/bigZips/chromFa.tar.gz</a></p><p>解压之后是按染色体分开的多个文件，需要自己合并再建索引。</p><p>但是UCSC上可以很方便的获取一段基因组的序列，如：</p><p><a href="http://genome.ucsc.edu/cgi-bin/das/hg38/dna?segment=chr17:7676091,7676196" title="http://genome.ucsc.edu/cgi-bin/das/hg38/dna?segment=chr17:7676091,7676196">http://genome.ucsc.edu/cgi-bin/das/hg38/dna?segment=chr17:7676091,7676196</a></p><h2 id="Ensembl-biomart"><a href="#Ensembl-biomart" class="headerlink" title="Ensembl biomart"></a>Ensembl biomart</h2><p>以hg19为例：</p><p><a href="http://ftp.ensembl.org/pub/release-56/fasta/homo_sapiens/dna/" title="http://ftp.ensembl.org/pub/release-56/fasta/homo_sapiens/dna/">http://ftp.ensembl.org/pub/release-56/fasta/homo_sapiens&#x2F;dna&#x2F;</a></p><p><img src="/image/image_OC017nTNhH.png"></p><p>也是只有单个染色体的文件</p><h2 id="GO-GET-DATA-GGD"><a href="#GO-GET-DATA-GGD" class="headerlink" title="GO GET DATA (GGD)"></a>GO GET DATA (GGD)</h2><p><a href="https://gogetdata.github.io/recipes.html#recipes" title="https://gogetdata.github.io">https://gogetdata.github.io</a></p><p>GGD是一个参考数据的管理软件，收集整理了包括人和小鼠的常见的参考数据。</p><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda install -c bioconda ggd<br></code></pre></td></tr></table></figure><p>搜索</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ggd search grch38 reference genome<br></code></pre></td></tr></table></figure><p>或者直接在他们的数据集里面找：<a href="https://gogetdata.github.io/recipes.html#recipes" title="https://gogetdata.github.io/recipes.html#recipes">https://gogetdata.github.io/recipes.html#recipes</a></p><p>下载，以hg19为例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ggd install hg19-reference-genome-ucsc-v1<br></code></pre></td></tr></table></figure><h2 id="Google-life-science"><a href="#Google-life-science" class="headerlink" title="Google life science"></a>Google life science</h2><p>Google life science是谷歌云的生物数据业务，其将一部分参考数据放在了Google storage上，地址在<a href="https://console.cloud.google.com/storage/browser/genomics-public-data?pageState=(%22StorageObjectListTable%22:(%22f%22:%22%255B%255D%22))&prefix=&forceOnObjectsSortingFiltering=false" title="这里">这里</a>，不过只有人的数据，而且比较乱，更多的是DNAseq分析要用的数据，比如GATK variant call。</p><p><img src="/image/image_gVKepMmM45.png"></p><p>下载需要用Google storage的命令行工具 <code>gsutli</code></p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda install -c conda-forge gsutil<br></code></pre></td></tr></table></figure><p>下载示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gsutil <span class="hljs-built_in">cp</span> gs://genomics-public-data/references/b37/Homo_sapiens_assembly19.fasta.gz .<br></code></pre></td></tr></table></figure><h2 id="AWS-iGenomes"><a href="#AWS-iGenomes" class="headerlink" title="AWS iGenomes"></a>AWS iGenomes</h2><p><a href="https://ewels.github.io/AWS-iGenomes/" title="https://ewels.github.io/AWS-iGenomes/">https://ewels.github.io/AWS-iGenomes/</a></p><p>这是大佬Phil Ewels开发的，参考数据除了有fasta以外还有GTF和BED文件，甚至还可以直接下载常见比对软件的索引文件，这样就可以节省大把的建索引的时间。而且文件放在AWS上，下载很方便，速度很快。</p><p><img src="/image/image_BHquud6ilu.png"></p><p>安装awscli</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install awscli<br><span class="hljs-comment">#or</span><br>conda install -c conda-forge awscli<br><br></code></pre></td></tr></table></figure><p>下载示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws s3 --no-sign-request --region eu-west-1 <span class="hljs-built_in">sync</span> s3://ngi-igenomes/igenomes/Homo_sapiens/UCSC/hg19/Sequence/BWAIndex/ ./references/Homo_sapiens/UCSC/hg19/Sequence/BWAIndex/<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些方式各有各的好处，总结一下就是：</p><ul><li><p>如果是用来bwa&#x2F;bowtie等比对软件，可以直接在AWS iGenomes下载，又快又好；</p></li><li><p>如果是要用来跑GATK variant calling流程，必须要用Google life science上面GATK配套的数据；</p></li><li><p>如果是想获取一段DNA序列，用UCSC和biomart都可以。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>参考数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基因ID转换的方法</title>
    <link href="/2020/06/04/%E5%9F%BA%E5%9B%A0ID%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2020/06/04/%E5%9F%BA%E5%9B%A0ID%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>不知道有多少人像我一样很奇怪为何基因的ID没有统一的命名，而且gene symbol也经常五花八门，导致我们经常要将拿到的gene list转换到需要的ID版本。</p><p>这样做的方法有很多，思路主要有两种，一种是下载相应的记录各种ID的匹配文件然后自己写脚本进行匹配，另一种是不下载文件，但是是实时访问数据库（API）进行查询。前者速度上有优势，但是下载的文件需要妥善存放，否则不知什么时候就找不到了；后者方便，随用随取，但是当查询量太大的话可能会出现网络方面的问题。</p><p>基本上每个这类数据库（NCBI, Ensembl…）都有这类文件的下载入口或者快捷访问的API，我试过很多，这里记录一下我觉得最方便的两个方式。</p><h2 id="1-从HGNC下载对应ID匹配文件"><a href="#1-从HGNC下载对应ID匹配文件" class="headerlink" title="1. 从HGNC下载对应ID匹配文件"></a>1. 从HGNC下载对应ID匹配文件</h2><p>从HGNC的Customs Dowloads可以自定义选择你所需要的内容，一般常用的是NCBI Gene ID和Ensembl gene ID。下载完成之后保存到固定的地方，每次要转换ID时再读取即可。</p><p>地址：<a href="https://www.genenames.org/download/custom/" title="https://www.genenames.org/download/custom/">https://www.genenames.org/download/custom/</a></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhe343twbj30tb0nk0wt.jpg"></p><h2 id="2-使用MyGene-API"><a href="#2-使用MyGene-API" class="headerlink" title="2. 使用MyGene API"></a>2. 使用MyGene API</h2><p><a href="https://mygene.info/" title="MyGene">MyGene</a>是<a href="https://biothings.io/%E4%B8%89%E5%8F%89%E6%88%9F%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%EF%BC%8C%E4%B8%89%E5%8F%89%E6%88%9F%E9%83%BD%E6%98%AF%E5%BE%88%E5%BC%BA%E5%A4%A7%E7%9A%84API%E3%80%82" title="https://biothings.io/三叉戟中的一个，三叉戟都是很强大的API。">https://biothings.io/三叉戟中的一个，三叉戟都是很强大的API。</a></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhe8b06a9j311v0ijh1f.jpg"></p><p>网站中有很详细的API示例：&amp;#x20;</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhe9ak9vwj31hp0pfdl0.jpg"></p><p>如果不会用API也没有关系，MyGene有对应的<a href="https://pypi.org/project/mygene/" title="python包">python包</a>和<a href="https://www.bioconductor.org/packages/release/bioc/html/mygene.html" title="r包">r包</a>，效果和API没有差别。</p><h2 id="3-Biomart"><a href="#3-Biomart" class="headerlink" title="3. Biomart"></a>3. Biomart</h2><p>最后再说一下介于前面两者之间的biomart，就和它的名字一样，它就是一个超市，你可以在线地选取你需要的数据集，就像是用API下载HGNC里的数据。biomart十分强大，但是在转换ID这件事情上我并不怎么用它，原因就是它太复杂，杀鸡焉用牛刀，而且最近好像连接不上。</p><hr><p>我最常用的是第一种。以ensembl ID转gene ID为例，我把从HGNC下载到的文件提取出ensembl ID到gene ID的字典，然后存成<code>pickle</code>，每次需要的时候就可以直接load，转换时用<code>map</code>，省时又省力。</p>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ID转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何优雅地清除复制文本所带的格式</title>
    <link href="/2020/06/04/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E6%B8%85%E9%99%A4%E5%A4%8D%E5%88%B6%E6%96%87%E6%9C%AC%E6%89%80%E5%B8%A6%E7%9A%84%E6%A0%BC%E5%BC%8F/"/>
    <url>/2020/06/04/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E6%B8%85%E9%99%A4%E5%A4%8D%E5%88%B6%E6%96%87%E6%9C%AC%E6%89%80%E5%B8%A6%E7%9A%84%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>就跟人类的本质一样，每个坐在电脑前的人使用最多快捷操作多半就是复制加粘贴。然而很多时候，这套快捷键并不能直接达到目的，因为粘贴的同时也粘贴内容原来的格式。其实这个问题也不大，无非就是用格式刷统一一下格式就行了，或者是先粘贴到浏览器搜索之类的地方先把附带的格式洗掉。这样一来，快捷键之后还要再花几秒时间，你是否还愿意称之为快捷操作呢。</p><p>我显然是不愿意多花这几秒钟的，毕竟人生苦短。</p><p>那么要怎么做才能优雅地粘贴呢？</p><p>答案很简单，在<a href="https://u.tools/" title="uTools">uTools</a>的自动化助手中简单设置一个快捷操作即可。</p><h2 id="uTools"><a href="#uTools" class="headerlink" title="uTools"></a>uTools</h2><p>uTools是一个很强大快捷操作工具箱，而且是免费的。</p><p>赞美的话就不多说了，就放一张我安装的插件，今天的主题是如何优雅的清除剪切板的格式。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfgjsxhoccj30e40bsgo0.jpg"></p><h2 id="第一步-安装uTools"><a href="#第一步-安装uTools" class="headerlink" title="第一步 安装uTools"></a>第一步 安装uTools</h2><p><a href="https://u.tools/" title="官网">官网</a>下载，安装很简单。</p><h2 id="第二步-安装自动化助手插件"><a href="#第二步-安装自动化助手插件" class="headerlink" title="第二步 安装自动化助手插件"></a>第二步 安装自动化助手插件</h2><p>呼出uTools之后输入插件中心，自动化助手就在首页，点击即可安装。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfgk0jix1uj30n80hotcc.jpg"></p><h3 id="第三步-新建自动化"><a href="#第三步-新建自动化" class="headerlink" title="第三步 新建自动化"></a>第三步 新建自动化</h3><p>新建一个自动化操作，读取剪切板里的内容并输出出来。</p><p>代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">const &#123; clipboard &#125; = require(<span class="hljs-string">&#x27;electron&#x27;</span>)  <br>  <br>const text = clipboard.readText()  <br>console.log(text)  <br>  <br>clipboard.writeText(text)<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfgk4g23mtj30n80i4gmj.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfgka72uitj30n80i4dhi.jpg"></p><h2 id="第四步-分配快捷键"><a href="#第四步-分配快捷键" class="headerlink" title="第四步 分配快捷键"></a>第四步 分配快捷键</h2><p>完成前三步其实就可以通过uTools输入清除格式来实现操作了，但是这样还不够优雅。我们可以直接给这个操作分配一个全局快捷键，设置步骤也很简单，我设置的是双击cmd，以后我只需在按下cmd V之前多按两下cmd就可以了。（uTools是支持Windows，macOS和Linux，我用的Mac所以用的是cmd）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfgkm94ac7j30n80ho0tw.jpg"></p><h2 id="其他的尝试"><a href="#其他的尝试" class="headerlink" title="其他的尝试"></a>其他的尝试</h2><p>在发现这个功能之前我还尝试过一些其他的方法。</p><h3 id="VS-code"><a href="#VS-code" class="headerlink" title="VS code"></a>VS code</h3><p>类似前面提到的浏览器搜索栏，因为基本上全天都打开着，所以年少无知的时候一直这么用。</p><h3 id="Mac自动操作"><a href="#Mac自动操作" class="headerlink" title="Mac自动操作"></a>Mac自动操作</h3><p>和uTools的自动化操作很像，但是没有分配快捷键的权限。</p><h3 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h3><p>Alfred的名气就不用说了，设置也非常简单，都不用自己试代码。但是Alfred只支持Mac，而且需要付费！</p>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python读Fastq新姿势</title>
    <link href="/2020/05/27/Python%E8%AF%BBFastq%E6%96%B0%E5%A7%BF%E5%8A%BF/"/>
    <url>/2020/05/27/Python%E8%AF%BBFastq%E6%96%B0%E5%A7%BF%E5%8A%BF/</url>
    
    <content type="html"><![CDATA[<p>分析二代测序数据时免不了要对fastq文件进行操作，然而也会出现想进行的操作并没有现成的工具可以实现的情况，这时候就需要自己写一个小脚本来读取fastq文件并进行操作。</p><p>其实用Python读取fastq文件的逻辑也很简单，根据fastq每四行为一个read的特点，边读边记行数，行数除4余2的行即位序列所在的行。这种方法看起来很naive，不过好像也没有更优雅的方式，直到我发现了mappy。</p><h1 id="mappy简介"><a href="#mappy简介" class="headerlink" title="mappy简介"></a>mappy简介</h1><p><a href="https://pypi.org/project/mappy/" title="mappy">mappy</a>是minimap2的Python版本，同样也是出自Li Heng，你可以使用它在Python程序直接实现和minimap2同样性能的比对工具，而不在需要从命令行调用。不要问为什么这么强，问就是Cython。</p><p>而这里我们需要用到的只是mappy的一个小小的功能：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf749qy6ouj30vf06vaaz.jpg"></p><p>可以看到mappy读取fastq只需要一行：<code>mp.fastx_read(&#39;./test.fq&#39;,read_comment=True)</code>，然后返回一个迭代器，内容是一个元组，read ID，序列包括质量等信息都在里面。</p><h1 id="mappy性能对比"><a href="#mappy性能对比" class="headerlink" title="mappy性能对比"></a>mappy性能对比</h1><p>这里通过一个小任务来比较mappy和我以前使用的方法的区别（其实也是Cython和Python的区别）</p><p>任务是将一个有1千万条read的fastq文件截取前50bp写进新fastq，read ID不变。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf74d2gk2pj30u309hwfx.jpg"></p><p>相比之下，不仅代码少了很多，而且时间缩短了约25%。</p><p>换成gzip压缩文件后：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf74mokiosj30va0acmys.jpg"></p><p>mappy的速度优势更明显了。</p><p>今天也是羡慕C的速度的一天呢😐。</p>]]></content>
    
    
    <categories>
      
      <category>NGS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Fastq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Affy Transcript Cluster ID转换</title>
    <link href="/2020/04/20/Affy%20Transcript%20Cluster%20ID%E8%BD%AC%E6%8D%A2/"/>
    <url>/2020/04/20/Affy%20Transcript%20Cluster%20ID%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>我在查看GSE103380的GEO2R结果的时候发现这个数据没有gene symbol，反而是一堆我看不懂的TC开头的ID，误打误撞发现居然有个在线工具可以转，而这些TC开头的ID是Affymatrix 的 Transcript Cluster ID。</p><p>这个工具叫<a href="https://biodbnet-abcc.ncifcrf.gov/db/db2db.php" title="bioDBnet">bioDBnet</a>，转换速度还可以。</p><p><img src="http://yanxuan.nosdn.127.net/989dee018f689f458050b9b97336cedb.png"></p><p><img src="http://yanxuan.nosdn.127.net/ca236a209cac42f2f777ef99b701c1a9.png"></p>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ID转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows科学上网方法</title>
    <link href="/2020/02/11/Windows%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%96%B9%E6%B3%95/"/>
    <url>/2020/02/11/Windows%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>科学上网（俗称翻墙）的方式有很多种，包括自己搭梯子、购买搭好的梯子和使用免费的梯子。</p><p>对于大多数人来说，选择一种经济实惠又不折腾的方法是很关键的，下面我就我科学上网的一些经验来谈谈如何选择合适的方式。</p><h2 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h2><p>掌握多种科学上网方式以保证随时的上网需求；免费的方式省钱但费点力，付费的方式花钱但省心还可以在IOS设备上使用；免费方式推荐浏览器插件：SetupVPN，付费方式推荐购买Shadowsocks账号。</p><h2 id="免费方式"><a href="#免费方式" class="headerlink" title="免费方式"></a>免费方式</h2><p>👴不是没有钱，👴就喜欢这种薅羊毛的感觉</p><h2 id="爬虫抓取免费账号"><a href="#爬虫抓取免费账号" class="headerlink" title="爬虫抓取免费账号"></a>爬虫抓取免费账号</h2><p>常见的免费方式就是使用爬虫抓取免费socks账号，有能力的可以自己抓或者使用别人的程序，别人Po在网上的往往是无效的，自己抓的也很难坚持很长时间。所以我不推荐这种方式。</p><p>如果非要用socks账号进行科学上网的话，点<a href="https://github.com/Alvin9999/new-pac/wiki/ss%E5%85%8D%E8%B4%B9%E8%B4%A6%E5%8F%B7" title="这里">这里</a>可以找到靠谱的免费SSR账号，基本上每天都会更新，因为经常会被封锁。</p><h2 id="使用免费软件"><a href="#使用免费软件" class="headerlink" title="使用免费软件"></a>使用免费软件</h2><h3 id="免费软件"><a href="#免费软件" class="headerlink" title="免费软件"></a>免费软件</h3><p>这样的软件有几个比如：<a href="https://getlantern.org/zh_CN/" title="lantern">lantern</a> 和<a href="https://freegate.en.softonic.com/" title="freegate">freegate</a></p><p>Lantern 要比Freegate好用一点，但是有一点比较头疼的是，GFW会在某些特殊时期加强，这时候这两个软件都没有办法发挥作用。</p><h3 id="免费浏览器插件"><a href="#免费浏览器插件" class="headerlink" title="免费浏览器插件"></a>免费浏览器插件</h3><p>我在Windows上主要使用Chrome，所以在这里推荐几款Chrome上的科学上网插件。 &amp;#x20;<br>更新：微软的chromium内核的新Edge浏览器已经发布正式版了，下面提到的插件都直接可以在应用商店下载，而且不需要翻墙。</p><h4 id="SetupVPN"><a href="#SetupVPN" class="headerlink" title="SetupVPN"></a>SetupVPN</h4><p><img src="https://i.loli.net/2020/02/21/mbqeXkd5vHIGWzY.png"></p><p>是一款浏览器插件，无法配置自动代理，网速一般，但是免费。能翻墙就直接在浏览器应用商店搜索安装，</p><p>无法翻墙有两种方法：</p><ol><li><p>下载插件文件安装</p></li><li><p>1.  下载Chrome插件crx文件，<a href="http://www.chajianmi.com/download/oofgbpoabipfcfjapgnbbjjaenockbdp" title="http://www.chajianmi.com/download/oofgbpoabipfcfjapgnbbjjaenockbdp">http://www.chajianmi.com/download/oofgbpoabipfcfjapgnbbjjaenockbdp</a></p><ol><li><p>将下载文件的后缀名改成zip或者rar，然后解压</p></li><li><p>进入Chrome扩展程序管理页面，打开右上角开发者模式</p></li><li><p>将解压的文件夹拖该页面安装即可</p></li></ol></li><li><p>尝试蓝灯翻墙</p></li></ol><p>蓝灯有的时候可以短暂的翻墙，有的时候完全不行。运气好的话连接成功就可以在Chrome上登入你的Google账户，这样你之前安装过的插件都会被同步过来，如果你没有安装过setupVPN也可以通过商店安装。</p><h4 id="谷歌上网助手"><a href="#谷歌上网助手" class="headerlink" title="谷歌上网助手"></a>谷歌上网助手</h4><p><img src="https://i.loli.net/2020/02/21/ym8VWu2UFfpidZo.png"></p><p>不像SetupVPN，这款插件只能访问部分google的服务，可以使用google搜索引擎，Gmail和google scholar，但是不能上YouTube，Twitter等非google网站更是不用说了。不过好在这个插件速度明显要比SetupVPN要快，所以非常适合国内的科研人员。还有一点不容忽视，即SetupVPN无法自动代理，因此在访问很多国内的网站的时候很慢甚至无法加载，而谷歌上网助手就没有这个问题。</p><p>我一般是同时安装这两个插件根据不同的上网需求切换着用，最近好像SSR被封的特别厉害，反倒这些免费的方式成了最靠谱的方法了。</p><p>安装方法参照setupVPN的安装方法，能下载到crx就解压后拖到Chrome里，下载不到就想办法先翻墙，在Chrome应用商店里面下载。</p><h2 id="付费方式"><a href="#付费方式" class="headerlink" title="付费方式"></a>付费方式</h2><p>这时是不是有人就要问：既然免费的方法这么香，还要花钱折腾付费的干嘛？不是花钱找罪受吗？</p><p>花钱找罪受是不假。然而我们前面提到的免费的Chrome插件虽然方便省钱，但是很多时候却是满足不了我们的需求。比如我们需要全局代理而不只是在Chrome上翻墙，最常见的例子就是邮件客户端登陆Gmail，又或者MacOS用户只习惯用Safari，不喜欢流氓软件Chrome。更重要的是付费购买的梯子不只是可以在PC上科学上网，移动设备同样也可以。</p><p>现在付费的方式主要分两种，一种是自己搭建服务器，一种是购买别人搭建好的服务器上的账号。当然我们前面说的免费的软件和插件都有付费升级的选项，不推荐的原因有两个，一是贵，二是有前面说的局限性。</p><h2 id="自建服务器"><a href="#自建服务器" class="headerlink" title="自建服务器"></a>自建服务器</h2><p>也就是常说的VPS(Virtual Private Server)。原理就是租一台在海外的服务器，然后在上面搭建代理服务。我没有试过，原因是被价格全退了，基本上要20刀+&#x2F;年，现在好像还在涨。因为没有试过，所以我不知道这种方式的速度如何以及会不会被封锁，封锁了之后怎么办。不过感觉我也不会尝试。</p><h2 id="购买账号"><a href="#购买账号" class="headerlink" title="购买账号"></a>购买账号</h2><p>这个是我推荐的也是我正在使用的。</p><p><img src="https://i.loli.net/2020/02/21/3iIuUHeSOJX9p57.png"></p><p><a href="https://portal.shadowsocks.nl/" title="shadowsocks">shadowsocks</a>，俗称小飞机。我用了快一年半了，下面是我总结的小飞机的优点和缺点。</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li><p>便宜。我买的是入门版，96RMB&#x2F;年，双十一的时候还有活动三年只需两年的价格。每个月60G流量根本用不完，而且我怀疑他的流量计算有问题，我基本上每天都看YouTube，但是每个月的流量都不超过1G。</p></li><li><p>方便。Mac，Windows，iPhone，iPad都可以用。自动代理和全局代理随意切换。</p></li><li><p>省事。虽然现在动不动就被封禁，但是人家毕竟是靠这个赚钱的，所以每次被封禁都会第一时间想办法解决，还会有一定的补偿。之前是只支持SSR，去年下半年遭到长时间封禁之后有支持了v2ray，现在又在尝试支持trojan。</p></li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>不稳定。因为用户群体数量大，所以成为了每次封禁首当其冲的对象。不知道新的trojan会不会好一点。</li></ul><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><h4 id="1-购买账号"><a href="#1-购买账号" class="headerlink" title="1. 购买账号"></a>1. 购买账号</h4><p>购买链接：<a href="https://portal.shadowsocks.nl/cart.php" title="https://portal.shadowsocks.nl/cart.php">https://portal.shadowsocks.nl/cart.php</a></p><p>使用我的<a href="https://portal.shadowsocks.nl/aff.php?aff=28197" title="推荐链接">推荐链接</a>可以便宜一点，具体便宜多少我也不知道。</p><h4 id="2-安装客户端”-2-安装客户端"><a href="#2-安装客户端”-2-安装客户端" class="headerlink" title="2. 安装客户端”)2. 安装客户端"></a>2. 安装客户端”)2. 安装客户端</h4><p>Windows的客户端有两个：shadowscocks和v2ray。shadowsocks只支持SSR，不支持v2ray，v2ray都支持。</p><p>网上的一些教程说还要安装SwithyOmega的插件。个人觉得完全没有必要，而且这个插件也不好用。</p><h4 id="shadowscocks"><a href="#shadowscocks" class="headerlink" title="shadowscocks"></a>shadowscocks</h4><p>在GitHub上下载最新的(不是最新的可能不支持你的加密方式)客户端，<a href="https://github.com/shadowsocks/shadowsocks-windows/releases%E3%80%82%E5%8F%8C%E5%87%BB%E5%AE%89%E8%A3%85%E7%84%B6%E5%90%8E%E7%99%BB%E9%99%86%E8%B4%A6%E5%8F%B7%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86%E3%80%82" title="https://github.com/shadowsocks/shadowsocks-windows/releases。双击安装然后登陆账号就可以了。">https://github.com/shadowsocks/shadowsocks-windows/releases。双击安装然后登陆账号就可以了。</a></p><h4 id="v2ray"><a href="#v2ray" class="headerlink" title="v2ray"></a>v2ray</h4><p>从github下载v2ray内核</p><p><a href="https://github.com/v2ray/v2ray-core/releases" title="https://github.com/v2ray/v2ray-core/releases">https://github.com/v2ray/v2ray-core/releases</a></p><p>再下载图形界面</p><p><a href="https://github.com/2dust/v2rayN/releases/" title="https://github.com/2dust/v2rayN/releases/">https://github.com/2dust/v2rayN/releases/</a></p><p>将图形界面文件解压移动到内核文件内运行v2rayN.exe即可。</p><p>最后祝大家都能够省心地科学上网。</p>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>VPN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用ShapeIT2进行单倍型分型</title>
    <link href="/2019/11/14/%E4%BD%BF%E7%94%A8ShapeIT2%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%80%8D%E5%9E%8B%E5%88%86%E5%9E%8B/"/>
    <url>/2019/11/14/%E4%BD%BF%E7%94%A8ShapeIT2%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%80%8D%E5%9E%8B%E5%88%86%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="ShapeIT2支持两种phasing的方法-for-unrelated-individuals-without-family-information"><a href="#ShapeIT2支持两种phasing的方法-for-unrelated-individuals-without-family-information" class="headerlink" title="ShapeIT2支持两种phasing的方法 (for unrelated individuals without family information)"></a>ShapeIT2支持两种phasing的方法 (for unrelated individuals without family information)</h2><ul><li><p>使用参考面板</p></li><li><p>不使用参考面板</p></li></ul><p>输入文件都是VCF文件。</p><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><ol><li><p>将VCF按照染色体分开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">vcftools --gzvcf chinese-han.phase3.genotypes.vcf.gz \<br>         --chr 22 \<br>         --recode \<br>         --recode-INFO-all \<br>         --remove-filtered-all \<br>         --min-alleles 2 \<br>         --max-alleles 2 \<br>         --out chinese_chr22<br></code></pre></td></tr></table></figure></li><li><p>phasing</p><ol><li><p>不使用参考面板</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">shapeit --input-vcf gwas.vcf \<br>        -M genetic_map.txt \<br>        -O gwas.phased \<br>        -T 4<br></code></pre></td></tr></table></figure></li><li><p>使用参考面板</p><p>使用1000G作为参考面板。</p><ol><li><p>Check SNP between INPUT and REF PANEL</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">shapeit -check \<br>        --input-vcf test_chr22.recode.vcf \<br>        -M ~/one_thousand_genome/1000GP_Phase3/genetic_map_chr22_combined_b37.txt \<br>        --input-ref ~/one_thousand_genome/1000GP_Phase3/1000GP_Phase3_chr22.hap.gz \<br>        ~/one_thousand_genome/1000GP_Phase3/1000GP_Phase3_chr22.legend.gz \<br>        ~/one_thousand_genome/1000GP_Phase3/1000GP_Phase3.sample \<br>        --output-log test_chr22.alignments<br></code></pre></td></tr></table></figure></li><li><p>Phase wirh REF (exclude SNPs in .strand.exclude)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">shapeit --input-vcf test_chr22.recode.vcf \<br>        -M ~/one_thousand_genome/1000GP_Phase3/genetic_map_chr22_combined_b37.txt \<br>        --input-ref ~/one_thousand_genome/1000GP_Phase3/1000GP_Phase3_chr22.hap.gz \<br>        ~/one_thousand_genome/1000GP_Phase3/1000GP_Phase3_chr22.legend.gz \<br>        ~/one_thousand_genome/1000GP_Phase3/1000GP_Phase3.sample \<br>        -O test_chr22.phased.with.ref \<br>        --exclude-snp test_chr22.alignments.snp.strand.exclude \<br>        -T 4<br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>生信教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GWAS</tag>
      
      <tag>Imputation</tag>
      
      <tag>Phasing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Linux服务器间快速传输大型文件</title>
    <link href="/2019/10/22/%E5%9C%A8Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%B4%E5%BF%AB%E9%80%9F%E4%BC%A0%E8%BE%93%E5%A4%A7%E5%9E%8B%E6%96%87%E4%BB%B6/"/>
    <url>/2019/10/22/%E5%9C%A8Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%B4%E5%BF%AB%E9%80%9F%E4%BC%A0%E8%BE%93%E5%A4%A7%E5%9E%8B%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Sometimes we need to back up data from a server to another using <code>scp</code> or <code>rsync</code>. It is very time-consuming when the data is very large, for example, over 500G. I found a combined command that helped me a lot.</p></blockquote><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>将你的文件分成若干个小文件；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">split</span> -b 1G large_file.txt.gz large_file/large_file.txt.gz.part-<br><br></code></pre></td></tr></table></figure><p><code>-b</code>指定文件大小</p></li><li><p>传输分裂后的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp large_file/large_file.txt.gz.part-* user@xx.xx.xx:/path/of/destination<br><br></code></pre></td></tr></table></figure><p>也可以使用并行同时传输多个文件，虽然速度不会有提升，因为主要的限制来自宽带，但是分裂文件可以解决因为网络问题造成的传输中断</p></li><li><p>将传输过去的小文件合并。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> large_file.txt.gz.part-* &gt; large_file.txt.gz<br></code></pre></td></tr></table></figure><p>也可以用md5进行校验。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>文件传输</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基因芯片中TOP/BOT Strand and A/B Allele的区别</title>
    <link href="/2019/10/12/%E5%9F%BA%E5%9B%A0%E8%8A%AF%E7%89%87ABAllele%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2019/10/12/%E5%9F%BA%E5%9B%A0%E8%8A%AF%E7%89%87ABAllele%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="“TOP-x2F-BOT”-Strand-and-“A-x2F-B”-Allele"><a href="#“TOP-x2F-BOT”-Strand-and-“A-x2F-B”-Allele" class="headerlink" title="“TOP&#x2F;BOT” Strand and “A&#x2F;B” Allele"></a>“TOP&#x2F;BOT” Strand and “A&#x2F;B” Allele</h2><p>Rather than referencing the evolving public databases to provide accurate SNP strand and orientation, Illumina has developed a method to consistently designate SNPs based on the actual or contextual sequence of each individual SNP.The advantage of this method is that it will consistently designate the same SNP orientation and allele calls even if public SNP databases and genome assemblies change. This will enable researchers worldwide to easily correlate the genotype calls made today to research that may have been completed several years ago.&amp;#x20;</p><p><img src="https://i.loli.net/2020/04/14/7ANoghndUsFQljG.png"></p><p><a href="https://i.loli.net/2020/04/14/7ANoghndUsFQljG.png" title="image.png">image.png</a></p><ul><li><p>A in Candidate allele: TOP</p></li><li><p>T in Candidate allele: BOT</p></li></ul><h4 id="sequence-walking"><a href="#sequence-walking" class="headerlink" title="sequence walking"></a>sequence walking</h4><p>If the SNP is an A&#x2F;T] or a [C&#x2F;G], then the above rules do not apply. &amp;#x20;</p><p><img src="https://i.loli.net/2020/04/14/GXgkm7rOL3VhTPb.png"></p><ul><li><p>To designate Strand, when the A or T in the first unambiguous pair is on the 5’ side of the SNP, then the sequence is designated TOP. When the A or T in the first unambiguous pair is on the 3’ side of the SNP, then the sequence is designated BOT.</p></li><li><p>To designate Allele for an [A&#x2F;T] SNP, when the Strand is TOP then Allele A &#x3D; A and Allele B &#x3D; T. When the Strand is BOT, then Allele A &#x3D; T and Allele B &#x3D;A.</p></li><li><p>To designate Allele for a [C&#x2F;G] SNP, when the Strand is TOP then Allele A &#x3D; C and Allele B &#x3D; G. When the Strand is BOT then Allele A &#x3D; G and Allele B &#x3D; C.</p></li></ul><p><img src="https://i.loli.net/2020/04/14/Fz432xZifpHmCrt.png"></p>]]></content>
    
    
    <categories>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GWAS</tag>
      
      <tag>基因分型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git快速入门</title>
    <link href="/2019/09/11/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2019/09/11/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>安装 Git</p><p>For Linux:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install git<br></code></pre></td></tr></table></figure><p>安装完成后，还需要最后一步设置，在命令行输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global user.name <span class="hljs-string">&quot;Your Name&quot;</span><br>$ git config --global user.email <span class="hljs-string">&quot;email@example.com&quot;</span><br><br></code></pre></td></tr></table></figure><p><code>–global</code>参数表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h2 id="创建版本库-本地"><a href="#创建版本库-本地" class="headerlink" title="创建版本库 (本地)"></a>创建版本库 (本地)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> learngit<br>$ <span class="hljs-built_in">cd</span> learngit<br>$ git init<br></code></pre></td></tr></table></figure><p>当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。</p><h2 id="添加文件到版本库"><a href="#添加文件到版本库" class="headerlink" title="添加文件到版本库"></a>添加文件到版本库</h2><p>第一步，创建文件，把文件放入你的git过的目录下：</p><p>文件内容示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Git is a version control system.<br>Git is free software.<br></code></pre></td></tr></table></figure><p>第二步，用命令git add告诉Git，把文件添加到仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add readme.txt<br><br></code></pre></td></tr></table></figure><p>第三步，用命令git commit告诉Git，把文件提交到仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit -m <span class="hljs-string">&quot;wrote a readme file&quot;</span><br><br></code></pre></td></tr></table></figure><p>git commit命令-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p>commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add file1.txt<br>$ git add file2.txt file3.txt<br>$ git commit -m <span class="hljs-string">&quot;add 3 files.&quot;</span><br><br></code></pre></td></tr></table></figure><p>更改文件并提交更改</p><ol><li><p>修改文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Git is a distributed version control system.<br>Git is free software.<br></code></pre></td></tr></table></figure></li><li><p>运行git status命令看看结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git status<br><br></code></pre></td></tr></table></figure></li><li><p>提交修改并说明</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add readme.txt<br>$ git commit -m <span class="hljs-string">&quot;add distributed&quot;</span><br><br></code></pre></td></tr></table></figure></li></ol><p>用git diff可以查看修改内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git diff readme.txt <br>diff --git a/readme.txt b/readme.txt<br>index 46d49bf..9247db6 100644<br>--- a/readme.txt<br>+++ b/readme.txt<br>@@ -1,2 +1,2 @@<br>-Git is a version control system.<br>+Git is a distributed version control system.<br> Git is free software.<br></code></pre></td></tr></table></figure><h2 id="远程库（GitHub）"><a href="#远程库（GitHub）" class="headerlink" title="远程库（GitHub）"></a>远程库（GitHub）</h2><p>现在的情景是，本地创建了一个Git仓库后，再在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。</p><h3 id="第1步：创建SSH-Key"><a href="#第1步：创建SSH-Key" class="headerlink" title="第1步：创建SSH Key"></a>第1步：创建SSH Key</h3><p>在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，创建SSH Key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br><br></code></pre></td></tr></table></figure><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p><p>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p><h3 id="第2步：登陆GitHub"><a href="#第2步：登陆GitHub" class="headerlink" title="第2步：登陆GitHub"></a>第2步：登陆GitHub</h3><ol><li><p>登陆GitHub，打开“Account settings”，“SSH Keys”页面，然后点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容；</p></li><li><p>然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库；</p></li><li><p>在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库；</p></li><li><p>把一个已有的本地仓库与之关联</p><p>现在，我们根据GitHub的提示，在本地的git仓库下运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote add origin git@github.com:michaelliao/learngit.git<br>$ git push -u origin master<br></code></pre></td></tr></table></figure><p>从现在起，只要本地作了提交，就可以通过命令： &amp;#x20;</p></li><li><p>把本地仓库的内容推送到GitHub仓库；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin master<br><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>命令行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
